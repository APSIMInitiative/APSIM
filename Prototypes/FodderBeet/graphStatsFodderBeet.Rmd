---
title: "Stats"
output: word_document
---

Table of stats

```{r ReadObserved, echo=FALSE, include=FALSE}
library(dplyr)
library(ggplot2)
library(lubridate)
library (hydroGOF)
library(xtable)
library(knitr)
library(tidyr)
library(RSQLite)

# load data
setwd("C:\\GitHubRepos\\ApsimX\\Prototypes\\FodderBeet\\Observations")
obsData <- read.table("ObservedDataForStats.txt", header = TRUE)

# get time format right
obsData <- obsData %>% mutate(Date = dmy(Date))
str(obsData)
head(obsData)
summary(obsData)

# create N categories
obsData$N_cat <- NULL
obsData$N_cat[obsData$N_Treat<=75] <- "low N"
obsData$N_cat[obsData$N_Treat>75 & obsData$NTrmt<=150] <- "mid N"
obsData$N_cat[obsData$N_Treat>150] <- "high N"


# create yield categories
obsData$yieldCat <- NULL
obsData$yieldCat[obsData$N_lim== "No" & obsData$W_lim== "No"] <- "Potential"
obsData$yieldCat[obsData$N_lim== "Yes" & obsData$W_lim== "No"] <- "N-limited only"
obsData$yieldCat[obsData$N_lim== "No" & obsData$W_lim== "Yes"] <- "Water-limited only"
obsData$yieldCat[obsData$N_lim== "Yes" & obsData$W_lim== "Yes"] <- "Co-limited"

obsData$N_cat <- as.factor(obsData$N_cat)

summary(obsData)

print(unique(obsData$Name))

```


```{r CustumStats}

gauchStats <- function(sim, meas) {
  
  n_s <- length(sim)
  n_m <- length(meas)
  model <- lm(meas~sim)
  sim_sq <- sum((sim - mean(sim))^2)
  mes_sq <- sum((meas - mean(meas))^2)
  r2 <- summary(model)$r.squared
  slope <- model$coefficients[[2]]
  
  sb <- (sum(mean(meas)) - sum(mean(sim)))^2
  nu <- (1-slope)^2 * (sim_sq/n_s)
  lc <- (1-r2) * (mes_sq/n_m)
  msd <- sb+nu+lc
  
  sb_r <- round((sb/msd)*100,1)
  nu_r <- round((nu/msd)*100,1)
  lc_r <- round((lc/msd)*100,1)
  
  msd_r <- sb_r+nu_r+lc_r
  
  out <- c(sb_r,nu_r,lc_r, msd_r)
 # out <- c(sb,nu,lc, msd,sim_sq,mes_sq,r2,n_s,n_m,slope ) # testing
  
  return(out)
  
}

# test dataset
s <- c(342.5,	68.3,	70.1,	286.1,	333.8)
m <- c(299.64,	161.36,	201.45,	220.8,	217.67)



x <- gauchStats(s,m)

x[1]
x[2]
x[3]
x[4]
x[5]
x[6]
x[7]
x[8]
x[9]
x[10]



```





```{r, ReadSimulated, echo=FALSE, include=FALSE}
# load Justin's function
GetApsimNGTable <- function(dbLoc, table) 
{
    connection <- dbConnect(SQLite(), dbname = dbLoc, flags = SQLITE_RW)
    table <- dbReadTable(connection, table, row.names=NULL)
    dbDisconnect(connection)
    return(table)
}

dbPath <- "C:\\GitHubRepos\\ApsimX\\Prototypes\\FodderBeet\\"

dbName <- "FodderBeet.db.Report.csv"
#dbName <- "SimData.txt"

myDb <- read.csv(paste0(dbPath,dbName), header=TRUE)
#myDb <- read.table("C:\\GitHubRepos\\ApsimX\\Prototypes\\FodderBeet\\SimData.txt", header=TRUE)

# get date sorted
myDb$Date <- ymd(myDb$Clock.Today)

# remove unecessary variables
myDb <- myDb %>%
  dplyr::select(-FodderBeet.Phenology.CurrentPhaseName, 
         -Phenology.Photoperiod.Value)

summary(myDb)
head(myDb)
str(myDb)

myDb$Name <- gsub(" ", "", myDb$Name, fixed = TRUE)

myDb %>%
  filter(Name == "LincolnP21_Cv2012") %>%
  summary()


```


```{r MergeObsPred, echo=FALSE, include=FALSE}

# Add info for merging



# re-arrange
outVarsPos <- grep("FodderBeet",names(myDb)) # find output variables
simData <- myDb %>% gather("Variable", "Predicted", outVarsPos)

head(simData)
head(obsData)
str(simData)
summary(simData)
summary(obsData)

mergedDF <- merge(obsData,simData, by=c("Date","Variable","Name")) # FIXME: add experiment?
head(mergedDF)
tail(mergedDF)
summary(mergedDF)

unique(mergedDF$Name)

mergedDF %>%
  filter(Name == "LincolnP21_Cv2012")

obsData %>%
  filter(Name == "LincolnP21_Cv2012")

simData %>%
  filter(Name == "LincolnP21_Cv2012")

summary(simData)
unique(simData$Name)

```



Potential yield

```{r, echo=FALSE,echo=FALSE, fig.height=18,fig.width=12}

varNameDf <- read.table("C:\\GitHubRepos\\ApsimX\\Prototypes\\FodderBeet\\VariableNames.txt", header = TRUE)
summary(varNameDf)

mergedDF <- merge(mergedDF,varNameDf, by="Variable")


mergedDF$SimpleName <- 
  factor(mergedDF$SimpleName, 
         levels = c("Node Number",
"Green Leaves",
"Seneced Leaves",
"LAI",
"Total DM",
"Bulb DM",
"Leaf DM",
"Petiole DM",
"Total N",
"Bulb N",
"Leaf N",
"Petiole N",
"Light Interception"
)
         )


# sort out xlim and ylim for graphs
maxAxesValues <- mergedDF %>%
  group_by(Calib_Test, SimpleName) %>%
  summarise(axes.limits = max(Observed, Predicted))
head(maxAxesValues, 20)

mergedDF <- merge(mergedDF, maxAxesValues, by=c("Calib_Test", "SimpleName"))


#potential
mergedDF %>%
#  filter(Name == "LincolnP21_Cv2011" | Name == "LincolnP21_Cv2012") %>%
#  filter(W_lim == "No", N_lim == "No") %>%
  filter(Calib_Test == "Calib") %>%
  ggplot(aes(x=Observed, y= Predicted)) +
  geom_point(aes(colour= Name, shape = Cultivar_Treat , size = 1)) +
  geom_abline(intercept = 0, slope = 1) +
  coord_fixed(ratio = 1) +
  facet_wrap(~SimpleName, scales = "free")

#potential

mergedDF %>%
  mutate(Calib_Test = ifelse(Calib_Test=="Calib","Calibration", "Testing"))  %>%
#  filter(Name == "LincolnP21_Cv2011" | Name == "LincolnP21_Cv2012") %>%
#  filter(W_lim == "No", N_lim == "No") %>%
 # filter(Calib_Test == "Calib") %>%
 # filter(SowingDate_Treat == "Oct") %>%
  ggplot(aes(x=Observed, y= Predicted)) +
  geom_point(aes(colour= Name, shape = Cultivar_Treat, size = 1.5)) +
  geom_abline(intercept = 0, slope = 1) +
  coord_fixed(ratio = 1) +
  facet_wrap(Calib_Test~SimpleName, scales = "free")

```


Stats table

```{r, echo=FALSE ,fig.align='right'}
# Give stats
mergedDF %>%
  group_by(Calib_Test,SimpleName) %>%
  summarise(
    n = n(),
    r2 = round(br2(Predicted,Observed)*100,0),
  #  rmse = round(rmse(Predicted,Observed),0),
    r_rmse = round(rmse(Predicted,Observed)/mean(Observed)*100,1),
    nse = round(NSE(Predicted,Observed),1),
    sb = gauchStats(Predicted,Observed)[1],
  nu = gauchStats(Predicted,Observed)[2],
  lc = gauchStats(Predicted,Observed)[3]
  ) %>%
  kable(format = "markdown")

```

